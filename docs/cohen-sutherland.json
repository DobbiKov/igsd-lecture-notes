{"version":1,"kind":"Article","sha256":"aa331e67c7c3651ad1299ce47b6049c4a454789836eb76506329d03356ee1f33","slug":"cohen-sutherland","location":"/cohen-sutherland.md","dependencies":[],"frontmatter":{"title":"Cohen Sutherland method","content_includes_title":false,"authors":[{"id":"Yehor KOROTENKO","name":"Yehor KOROTENKO"}],"exports":[{"format":"md","filename":"cohen-sutherland.md","url":"/build/cohen-sutherland-76ce6478488ba5a0b9c9dda7ea224172.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"code","lang":"cpp","value":"typedef int OutCode;\n\nconst int INSIDE = 0b0000;\nconst int LEFT   = 0b0001;\nconst int RIGHT  = 0b0010;\nconst int BOTTOM = 0b0100;\nconst int TOP    = 0b1000;\n\n// Compute the bit code for a point (x, y) using the clip rectangle\n// bounded diagonally by (xmin, ymin), and (xmax, ymax)\n\n// ASSUME THAT xmax, xmin, ymax and ymin are global constants.\n\nOutCode ComputeOutCode(double x, double y)\n{\n\tOutCode code = INSIDE;  // initialised as being inside of clip window\n\n\tif (x < xmin)           // to the left of clip window\n\t\tcode |= LEFT;\n\telse if (x > xmax)      // to the right of clip window\n\t\tcode |= RIGHT;\n\tif (y < ymin)           // below the clip window\n\t\tcode |= BOTTOM;\n\telse if (y > ymax)      // above the clip window\n\t\tcode |= TOP;\n\n\treturn code;\n}\n\n// Cohenâ€“Sutherland clipping algorithm clips a line from\n// P0 = (x0, y0) to P1 = (x1, y1) against a rectangle with \n// diagonal from (xmin, ymin) to (xmax, ymax).\nbool CohenSutherlandLineClip(double& x0, double& y0, double& x1, double& y1)\n{\n\t// compute outcodes for P0, P1, and whatever point lies outside the clip rectangle\n\tOutCode outcode0 = ComputeOutCode(x0, y0);\n\tOutCode outcode1 = ComputeOutCode(x1, y1);\n\tbool accept = false;\n\n\twhile (true) {\n\t\tif (!(outcode0 | outcode1)) {\n\t\t\t// bitwise OR is 0: both points inside window; trivially accept and exit loop\n\t\t\taccept = true;\n\t\t\tbreak;\n\t\t} else if (outcode0 & outcode1) {\n\t\t\t// bitwise AND is not 0: both points share an outside zone (LEFT, RIGHT, TOP,\n\t\t\t// or BOTTOM), so both must be outside window; exit loop (accept is false)\n\t\t\tbreak;\n\t\t} else {\n\t\t\t// failed both tests, so calculate the line segment to clip\n\t\t\t// from an outside point to an intersection with clip edge\n\t\t\tdouble x, y;\n\n\t\t\t// At least one endpoint is outside the clip rectangle; pick it.\n\t\t\tOutCode outcodeOut = outcode1 > outcode0 ? outcode1 : outcode0;\n\n\t\t\t// Now find the intersection point;\n\t\t\t// use formulas:\n\t\t\t//   slope = (y1 - y0) / (x1 - x0)\n\t\t\t//   x = x0 + (1 / slope) * (ym - y0), where ym is ymin or ymax\n\t\t\t//   y = y0 + slope * (xm - x0), where xm is xmin or xmax\n\t\t\t// No need to worry about divide-by-zero because, in each case, the\n\t\t\t// outcode bit being tested guarantees the denominator is non-zero\n\t\t\tif (outcodeOut & TOP) {           // point is above the clip window\n\t\t\t\tx = x0 + (x1 - x0) * (ymax - y0) / (y1 - y0);\n\t\t\t\ty = ymax;\n\t\t\t} else if (outcodeOut & BOTTOM) { // point is below the clip window\n\t\t\t\tx = x0 + (x1 - x0) * (ymin - y0) / (y1 - y0);\n\t\t\t\ty = ymin;\n\t\t\t} else if (outcodeOut & RIGHT) {  // point is to the right of clip window\n\t\t\t\ty = y0 + (y1 - y0) * (xmax - x0) / (x1 - x0);\n\t\t\t\tx = xmax;\n\t\t\t} else if (outcodeOut & LEFT) {   // point is to the left of clip window\n\t\t\t\ty = y0 + (y1 - y0) * (xmin - x0) / (x1 - x0);\n\t\t\t\tx = xmin;\n\t\t\t}\n\n\t\t\t// Now we move outside point to intersection point to clip\n\t\t\t// and get ready for next pass.\n\t\t\tif (outcodeOut == outcode0) {\n\t\t\t\tx0 = x;\n\t\t\t\ty0 = y;\n\t\t\t\toutcode0 = ComputeOutCode(x0, y0);\n\t\t\t} else {\n\t\t\t\tx1 = x;\n\t\t\t\ty1 = y;\n\t\t\t\toutcode1 = ComputeOutCode(x1, y1);\n\t\t\t}\n\t\t}\n\t}\n\treturn accept;\n}","position":{"start":{"line":3,"column":1},"end":{"line":96,"column":1}},"key":"TnuNJFF7by"}],"key":"lyldf9fjJr"}],"key":"i5srtNwT7d"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Methode du germe","url":"/methode-du-germe","group":"IGSD Lecture Notes"},"next":{"title":"Understanding atan2 function","url":"/atan2","group":"IGSD Lecture Notes"}}},"domain":"http://localhost:3000"}